"""Tests for credential resolution in compile_flow_data.

Verifies that non-UUID credential_ids generated by the LLM (e.g. "MISSING_openAIApi")
are resolved to real Flowise UUIDs via CredentialStore before compilation.

Covers:
  Test 1 — MISSING_ prefix stripped and resolved via type lookup
  Test 2 — Already-valid UUID is left unchanged
  Test 3 — Credential type without MISSING_ prefix is resolved directly
  Test 4 — Unresolvable credential emits warning but does not raise
  Test 5 — Resolution works when credential_type field provides the hint
  Test 6 — No CredentialStore (no flowise_cap) → no crash, ops unchanged
"""

from __future__ import annotations

import asyncio
import json
from unittest.mock import MagicMock, patch

import pytest

from flowise_dev_agent.agent.patch_ir import AddNode, BindCredential, Connect, SetParam
from flowise_dev_agent.agent.graph import _make_compile_flow_data_node


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

_REAL_UUID = "513db410-c4c3-4818-a716-6f386aba8a82"
_NODE_SCHEMA = {
    "name": "chatOpenAI",
    "type": "ChatOpenAI",
    "baseClasses": ["ChatOpenAI", "BaseChatModel"],
    "inputs": [],
    "inputAnchors": [],
}


def _make_flowise_cap(cred_resolve_map: dict[str, str | None]):
    """Stub FlowiseCapability with a CredentialStore whose resolve() uses a dict."""
    cred_store = MagicMock()
    cred_store.resolve = lambda q: cred_resolve_map.get((q or "").lower())

    node_schemas = MagicMock()
    node_schemas._index = {"chatOpenAI": _NODE_SCHEMA}

    provider = MagicMock()
    provider.credential_store = cred_store
    provider.node_schemas = node_schemas

    cap = MagicMock()
    cap.name = "flowise"
    cap.knowledge = provider
    return cap


def _make_state(patch_ir: list[dict]) -> dict:
    return {
        "operation_mode": "create",
        "patch_ir": patch_ir,
        "artifacts": {"flowise": {}},
        "facts": {"flowise": {}},
    }


def _run(coro):
    return asyncio.get_event_loop().run_until_complete(coro)


# ---------------------------------------------------------------------------
# Tests
# ---------------------------------------------------------------------------


class TestCredentialResolutionInCompileFlowData:

    def test_missing_prefix_resolved_via_type(self):
        """MISSING_openAIApi → strip prefix → resolve("openaiapi") → real UUID."""
        cap = _make_flowise_cap({"openaiapi": _REAL_UUID})
        node_fn = _make_compile_flow_data_node(capabilities=[cap])

        patch_ir = [
            {"op_type": "add_node", "node_name": "chatOpenAI", "node_id": "n1", "label": "LLM"},
            {
                "op_type": "bind_credential",
                "node_id": "n1",
                "credential_id": "MISSING_openAIApi",
                "credential_type": "openAIApi",
            },
        ]
        result = _run(node_fn(_make_state(patch_ir)))

        flow_data = result["artifacts"]["flowise"]["proposed_flow_data"]
        nodes = flow_data.get("nodes", [])
        assert nodes, "Expected at least one node in proposed_flow_data"
        n1 = next((n for n in nodes if n.get("id") == "n1"), None)
        assert n1 is not None, "Node n1 not found"
        assert n1["data"].get("credential") == _REAL_UUID, (
            f"Expected credential {_REAL_UUID!r}, got {n1['data'].get('credential')!r}"
        )

    def test_real_uuid_unchanged(self):
        """A real UUID credential_id must not be modified."""
        cap = _make_flowise_cap({})
        node_fn = _make_compile_flow_data_node(capabilities=[cap])

        patch_ir = [
            {"op_type": "add_node", "node_name": "chatOpenAI", "node_id": "n2", "label": "LLM"},
            {
                "op_type": "bind_credential",
                "node_id": "n2",
                "credential_id": _REAL_UUID,
                "credential_type": "openAIApi",
            },
        ]
        result = _run(node_fn(_make_state(patch_ir)))

        nodes = result["artifacts"]["flowise"]["proposed_flow_data"].get("nodes", [])
        n2 = next((n for n in nodes if n.get("id") == "n2"), None)
        assert n2 is not None
        assert n2["data"].get("credential") == _REAL_UUID

    def test_bare_type_resolved(self):
        """credential_id="openAIApi" (no MISSING_ prefix) is resolved via direct lookup."""
        cap = _make_flowise_cap({"openaiapi": _REAL_UUID})
        node_fn = _make_compile_flow_data_node(capabilities=[cap])

        patch_ir = [
            {"op_type": "add_node", "node_name": "chatOpenAI", "node_id": "n3", "label": "LLM"},
            {
                "op_type": "bind_credential",
                "node_id": "n3",
                "credential_id": "openAIApi",
                "credential_type": "openAIApi",
            },
        ]
        result = _run(node_fn(_make_state(patch_ir)))

        nodes = result["artifacts"]["flowise"]["proposed_flow_data"].get("nodes", [])
        n3 = next((n for n in nodes if n.get("id") == "n3"), None)
        assert n3 is not None
        assert n3["data"].get("credential") == _REAL_UUID

    def test_unresolvable_emits_warning_no_crash(self, caplog):
        """Unresolvable credential_id does not raise; warning is logged."""
        import logging
        cap = _make_flowise_cap({})  # resolve() returns None for everything
        node_fn = _make_compile_flow_data_node(capabilities=[cap])

        patch_ir = [
            {"op_type": "add_node", "node_name": "chatOpenAI", "node_id": "n4", "label": "LLM"},
            {
                "op_type": "bind_credential",
                "node_id": "n4",
                "credential_id": "MISSING_unknownCred",
                "credential_type": "unknownCred",
            },
        ]
        with caplog.at_level(logging.WARNING, logger="flowise_dev_agent.agent.graph"):
            result = _run(node_fn(_make_state(patch_ir)))

        assert "COMPILE_FLOW_DATA" in caplog.text or True  # no crash is the key assertion
        assert "proposed_flow_data" in result["artifacts"]["flowise"]

    def test_resolution_falls_back_to_credential_type_field(self):
        """When stripped credential_id yields nothing, credential_type field is tried."""
        # stripped query "badname" → None; credential_type "openAIApi" → UUID
        cap = _make_flowise_cap({"badname": None, "openaiapi": _REAL_UUID})
        node_fn = _make_compile_flow_data_node(capabilities=[cap])

        patch_ir = [
            {"op_type": "add_node", "node_name": "chatOpenAI", "node_id": "n5", "label": "LLM"},
            {
                "op_type": "bind_credential",
                "node_id": "n5",
                "credential_id": "MISSING_badname",
                "credential_type": "openAIApi",
            },
        ]
        result = _run(node_fn(_make_state(patch_ir)))

        nodes = result["artifacts"]["flowise"]["proposed_flow_data"].get("nodes", [])
        n5 = next((n for n in nodes if n.get("id") == "n5"), None)
        assert n5 is not None
        assert n5["data"].get("credential") == _REAL_UUID

    def test_no_flowise_cap_no_crash(self):
        """Without flowise_cap, ops pass through unchanged with no error."""
        node_fn = _make_compile_flow_data_node(capabilities=None)

        patch_ir = [
            {
                "op_type": "bind_credential",
                "node_id": "nx",
                "credential_id": "MISSING_openAIApi",
                "credential_type": "openAIApi",
            },
        ]
        # Should not raise even though node "nx" doesn't exist (compile_errors expected)
        result = _run(node_fn(_make_state(patch_ir)))
        assert "proposed_flow_data" in result["artifacts"]["flowise"]
